Negative Brand Signal Monitor
------------------------------
Industry 
Direct-to-Consumer (DTC) Brands 
 
Company Size 
5–50 employees 
 
Location 
Mostly North America and Europe 
 
Business Needs 
● Catch early signs of bad brand mentions 
● Monitor Reddit, Quora, etc 
● Understand what customers are upset or confused about 
● Respond before things go viral or hurt sales 
 
Tech Level 
Medium 
 
Decision Makers 
Founders 
 
Pain Points 
● Don’t know when people are talking negatively until it’s too late 
● Bad press or viral complaints hurt trust and conversion 
● Reactive Reputation Management 
● Virality Moves Faster Than Teams 
● Fragmented Feedback Channels 
● Misinterpreted Customer Signals 
● Manual Monitoring is Unsustainable 
 
Brand Behavior 
● Speed-Obsessed  
● Image-First Culture 
● Open to AI, Not Enterprise 
 
AI Opportunities 
● Multichannel Sentiment Sniffing 
● Sarcasm & Meme Detection Layer 
● Velocity (mentions per hour) 
● Language (negative, sarcastic, confused, angry) 
● AI-Powered Rapid Response Assistant 
 
Proposed Technical Solution 
 
Using Model Context Protocol (MCP) to detect and prioritize negative signals across key online channels 
 
Architecture Overview - Automated 
[MCP Feeds (Reddit, Quora)]→ [Signal Processor]→[Sentiment + Sarcasm Engine]→[Priority Queue]→[Response Assistant + Dashboard] 
 
Ingestion Layer (via MCP)- Automated Data Flow 
● Feeds: Reddit, Quora 
● MCP standardizes content (post body, comments, metadata)  
● Filter by brand mentions (fuzzy matching, brand aliases)  
 
Signal Processor - Fully Automated Processing 
● Lightweight service (Python/Node)  
● Tags incoming content:  
○ Source  
○ Thread popularity  
○ Mention velocity  
 
Sentiment + Sarcasm Engine - Fully Automated 
● Fine-tuned transformer (e.g., Distil Roberta or LLaMA2-lite)  
● Output tags:  
○ Sentiment: Negative / Neutral / Positive  
○ Tone: Angry, Confused, Sarcastic  
○ Intent: Complaint, Question, Rant, Meme  
 
Velocity + Virality Scoring - Fully Automated 
● Risk Score = Sentiment Weight × Tone Intensity × Virality  
● Detect spikes in mention frequency and engagement rates  
● Rapid Response Assistant 
 
GPT-powered - Fully Automated copilot to :  
● Suggest responses  
● Recommend an engagement strategy  
● Surface similar past issues  
 
Dashboard UI  - Real-Time Automated Monitoring: 
● Real-Time Alerts with Risk Score  
● Top Negative Threads  
● Sentiment Timeline
---------------------------------------------------------------------------------------------------------
Key Points
------------------------------
1. Scheduler: Vercel Cron Jobs 
https://vercel.com/docs/cron-jobs
https://vercel.com/pricing 

2. Backend Logic: Node.js within Vercel Serverless Functions
Node.js: https://nodejs.org/
Vercel Functions: https://vercel.com/docs/functions/serverless-functions
Vercel Pricing/Limits: https://vercel.com/pricing

3. Frontend & Hosting: React/Next.js on Vercel 
React: https://react.dev/
Next.js (by Vercel): https://nextjs.org/
Vercel Hosting/Pricing: https://vercel.com/pricing

4. Database: Vercel Postgres or Supabase 
Vercel Postgres: https://vercel.com/storage/postgres
Supabase: https://supabase.com/pricing

5. Data Source: Reddit API 
https://www.reddit.com/dev/api/

6. Sentiment/Tone Analysis: Hugging Face Inference API 
https://huggingface.co/docs/api-inference/index
https://www.google.com/search?q=https://huggingface.co/pricing%23inference-api

7. Response Assistance: Google Gemini API or similar 
Google AI / Gemini API: https://ai.google.dev/pricing 
Alternative (Anthropic): https://www.anthropic.com/pricing

---------------------------------------------------------------------------------------------------------

Flow Map:
------------------------------
1. Scheduled Fetching:
Vercel Cron Job -> Vercel Function (Node.js) -> Reddit API (Get Mentions) -> Free Tier DB (Save Raw Mention)

2. Sentiment Analysis (Triggered or Batched):
DB Trigger / Vercel Cron Job -> Vercel Function (Node.js) -> Hugging Face API (Analyze Text) -> Free Tier DB (Update Mention with Sentiment/Tone)

3. Risk Scoring (Scheduled):
Vercel Cron Job -> Vercel Function (Node.js) -> Free Tier DB (Read Analyzed Mentions) -> Calculate Velocity/Virality/Risk Score -> Free Tier DB (Update Mention with Risk Score)

4. Dashboard Display:
User -> Next.js Frontend (on Vercel) -> Vercel Function (API Route) -> Free Tier DB (Read Scored/Prioritized Mentions) -> Display Data to User

5. AI Response Assistance (User Triggered):
User (Clicks Assist Button on Dashboard) -> Vercel Function (API Route) -> Free Tier DB (Get Mention Context) -> Free Tier LLM API (e.g., Gemini - Generate Suggestion) -> Return Suggestion to Dashboard



---------------------------------------------------------------------------------------------------------
file structure:
---------------
1. app(components, lib ,globals.css, layout.js, page.js )
2. components(Dashboard.jsx, ErrorDisplay.jsx, LoadingSpinner.jsx, Mentionltem.jsx, MentionList.jsx, ResponseAssistant.jsx, SentimentBadge.jsx)
3. lib(api.js)
4. "dependencies": {"react": "^19.0.0","react-dom": "^19.0.0","next": "15.3.1"}
---------------------------------------------------------------------------------------------------------


lib/api.js
--------------------------
// --- MOCK DATA (Keep the sample data structure and mockMentions array as before) ---
const createSampleMention = (id, overrides) => ({
  id: `mention_${id}`,
  text: `This is sample mention ${id} text. @[BrandA] is okay, but @[BrandB] needs work. How about @[YourBrand]? Feels ${
    overrides?.sentiment || "Neutral"
  }.`, // Example text with multiple brands
  source: id % 2 === 0 ? "Reddit" : "Quora",
  url: `https://example.com/mention/${id}`,
  sentiment: "Negative",
  tone: "Confused",
  intent: "Question",
  riskScore: Math.floor(Math.random() * 100),
  timestamp: new Date(Date.now() - id * 3600 * 1000).toISOString(),
  threadPopularity: Math.floor(Math.random() * 200),
  velocity: Math.random() * 5,
  ...overrides,
});

const mockMentions = [
  createSampleMention(1, {
    brand: "BrandA",
    sentiment: "Negative",
    tone: "Angry",
    intent: "Complaint",
    riskScore: 92,
    text: "Worst experience ever with @BrandA! Product broke after one use.",
  }),
  createSampleMention(2, {
    brand: "BrandB",
    sentiment: "Negative",
    tone: "Sarcastic",
    intent: "Rant",
    riskScore: 75,
    text: "Oh yeah, @BrandB customer service was *so* helpful... /s",
  }),
  createSampleMention(3, {
    brand: "BrandA",
    sentiment: "Negative",
    tone: "Confused",
    intent: "Question",
    riskScore: 60,
    text: "Does anyone know how to actually use the @BrandA app? The instructions are unclear.",
  }),
  createSampleMention(4, {
    brand: "YourBrand",
    sentiment: "Neutral",
    intent: "Question",
    riskScore: 30,
    text: "Just asking about @YourBrand availability.",
  }),
  createSampleMention(5, {
    brand: "BrandB",
    sentiment: "Positive",
    riskScore: 10,
    text: "Had a great time using @BrandB new feature!",
  }),
  createSampleMention(6, {
    brand: "BrandA",
    sentiment: "Negative",
    riskScore: 88,
    text: "@BrandA website is down again! #fail",
  }),
];

const mockAssistanceResponse = {
  suggestion:
    "Hi there, thanks for reaching out about [Brand]. Could you tell us a bit more about the specific issue you encountered? We'd like to help make this right. Please feel free to DM us with your order details or specifics.",
  strategy:
    "Empathize, reference the mentioned brand, ask for details privately, offer resolution.",
};

// --- MOCK API FUNCTIONS ---

/**
 * MOCK: Fetches prioritized mentions for a specific brand query.
 * @param {string} brandQuery - The brand name to search for.
 */
export async function fetchMentions(brandQuery) {
  console.log(`MOCK API: Fetching mentions for query: "${brandQuery}"...`);
  await new Promise((resolve) => setTimeout(resolve, 800)); // Simulate network delay

  if (!brandQuery || brandQuery.trim() === "") {
    // console.log("MOCK API: No query provided, returning empty array.");
    return []; // Return empty if no query
    // OR: you could return all mentions if desired when query is empty
    // return [...mockMentions];
  }

  // Simulate filtering based on brandQuery (case-insensitive)
  const queryLower = brandQuery.toLowerCase();
  const results = mockMentions.filter(
    (mention) =>
      mention.text.toLowerCase().includes(`@${queryLower}`) || // Simple @mention check
      mention.text.toLowerCase().includes(queryLower) || // General text check
      (mention.brand && mention.brand.toLowerCase() === queryLower) // Check assigned brand if exists
  );

  console.log(
    `MOCK API: Found ${results.length} mentions for "${brandQuery}".`
  );
  return [...results]; // Return a copy of the filtered results
}

/**
 * MOCK: Requests AI assistance for a specific mention.
 * @param {string} mentionId - The ID of the mention.
 * @param {object} mentionContext - Relevant details (used slightly in mock).
 */
export async function fetchAssistance(mentionId, mentionContext) {
  console.log(
    `MOCK API: Fetching assistance for mention ${mentionId}...`,
    mentionContext
  );
  await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate AI delay

  // Simulate potential API error randomly
  // if (Math.random() < 0.1) {
  //   console.error("MOCK API: Simulated fetchAssistance error");
  //   throw new Error('Failed to get assistance (Simulated Error)');
  // }

  // Slightly customize response based on context
  let suggestion = mockAssistanceResponse.suggestion;
  if (mentionContext?.source) {
    suggestion = suggestion.replace(
      "[Brand]",
      `your ${mentionContext.source} post`
    );
  } else {
    suggestion = suggestion.replace("[Brand]", "your feedback");
  }

  return { ...mockAssistanceResponse, suggestion }; // Return customized copy
}






---------------------------------------------------------------------------
Dashboard.jsx
---------------
// app/components/Dashboard.jsx
'use client';

import React, { useState, useCallback } from 'react';
import MentionList from './MentionList';
import ResponseAssistant from './ResponseAssistant';
import LoadingSpinner from './LoadingSpinner';
import ErrorDisplay from './ErrorDisplay';
import { fetchMentions, fetchAssistance } from '../lib/api';

export default function Dashboard() {
    const [searchQuery, setSearchQuery] = useState('');
    const [activeSearchTerm, setActiveSearchTerm] = useState('');
    const [mentions, setMentions] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [error, setError] = useState(null);
    const [selectedMention, setSelectedMention] = useState(null);
    const [isAssistantLoading, setIsAssistantLoading] = useState(false);
    const [assistantResponse, setAssistantResponse] = useState(null);
    const [assistantError, setAssistantError] = useState(null);
    const [searchPerformed, setSearchPerformed] = useState(false);

    const performSearch = useCallback(async (brandQuery) => {
        if (!brandQuery) return;
        console.log(`Searching for brand: ${brandQuery}`);
        setIsSearching(true);
        setError(null);
        setMentions([]);
        setSearchPerformed(true);
        try {
            const fetchedMentions = await fetchMentions(brandQuery);
            const sortedMentions = fetchedMentions.sort((a, b) => (b.riskScore || 0) - (a.riskScore || 0));
            setMentions(sortedMentions);
        } catch (err) {
            setError(err.message || `Failed to load mentions for "${brandQuery}".`);
            setMentions([]);
        } finally {
            setIsSearching(false);
        }
    }, []);

    const handleInputChange = (event) => {
        setSearchQuery(event.target.value);
    };

    const handleSearchSubmit = (event) => {
        event.preventDefault();
        const trimmedQuery = searchQuery.trim();
        if (trimmedQuery) {
            setActiveSearchTerm(trimmedQuery);
            performSearch(trimmedQuery);
        } else {
            setActiveSearchTerm('');
            setMentions([]);
            setError(null);
            setSearchPerformed(false);
        }
    };

    // --- Handlers for AI Assistant (remain the same) ---
    const handleAssistClick = useCallback(async (mention) => {
        if (!mention || isAssistantLoading) return;
        setSelectedMention(mention);
        setAssistantResponse(null);
        setAssistantError(null);
        setIsAssistantLoading(true);
        try {
            const context = { /* ... context data ... */ };
            const response = await fetchAssistance(mention.id, context);
            setAssistantResponse(response);
        } catch (err) {
            setAssistantError(err.message || 'Failed to get assistance.');
            setAssistantResponse(null);
        } finally {
            setIsAssistantLoading(false);
        }
    }, [isAssistantLoading]);

    const handleCloseAssistant = () => {
        setSelectedMention(null);
        setAssistantResponse(null);
        setAssistantError(null);
    };

    // --- Render Logic ---
    // Use flex column to position search bar below results area
    return (
        <div className="flex flex-col h-[calc(100vh-10rem)]"> {/* Adjust height calculation based on header/padding */}

            {/* Main Content / Results Area (Mimics 'Dashboard' box) */}
            <div className="flex-grow overflow-y-auto p-4 mb-4 border border-gray-600 rounded-lg min-h-[200px]"> {/* Added border, padding, min-height */}
                {isSearching && <LoadingSpinner text={`Searching for "${activeSearchTerm}"...`} />}

                {error && <ErrorDisplay message={error} onRetry={() => performSearch(activeSearchTerm)} />}

                {!isSearching && !error && searchPerformed && mentions.length === 0 && (
                    <p className="text-center text-gray-400 py-4 italic">
                        No mentions found for "{activeSearchTerm}".
                    </p>
                )}

                {!isSearching && !error && !searchPerformed && mentions.length === 0 && (
                    <p className="text-center text-gray-400 py-4 italic">
                        Enter a brand name below and click Search.
                    </p>
                )}

                {/* Mention List */}
                {!isSearching && mentions.length > 0 && (
                    <div className={selectedMention ? 'opacity-50 pointer-events-none' : ''}>
                        <h2 className="text-xl font-semibold mb-4 text-gray-100">
                            Results for "{activeSearchTerm}"
                        </h2>
                        {/* Ensure MentionList/MentionItem styles are updated for dark mode */}
                        <MentionList mentions={mentions} onAssistClick={handleAssistClick} />
                    </div>
                )}
            </div>

            {/* Search Bar Area (Mimics bottom search bar) */}
            <div className="mt-auto p-2"> {/* Pushes search bar to the bottom */}
                <form onSubmit={handleSearchSubmit} className="relative flex items-center w-full max-w-4xl mx-auto"> {/* Centered, max width */}
                    <input
                        type="text"
                        value={searchQuery}
                        onChange={handleInputChange}
                        placeholder="Enter brand name (e.g., YourBrand)"
                        // Styling closer to the image: dark bg, rounded, larger text/padding
                        className="w-full px-5 py-3 pr-16 text-base bg-gray-700 border border-gray-600 rounded-xl focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 text-gray-100 placeholder-gray-400"
                        aria-label="Search Brand Mentions"
                        disabled={isSearching || !!selectedMention}
                    />
                    <button
                        type="submit"
                        // Position button inside input area if desired, or keep adjacent
                        className="absolute right-2 top-1/2 transform -translate-y-1/2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled={!searchQuery.trim() || isSearching || !!selectedMention}
                    >
                        {isSearching ? '...' : 'Search'} {/* Or use an icon */}
                    </button>
                </form>
            </div>


            {/* AI Response Assistant Modal (Render logic is the same, ensure its internal styles are dark-themed) */}
            {selectedMention && (
                <ResponseAssistant
                    mention={selectedMention}
                    response={assistantResponse}
                    isLoading={isAssistantLoading}
                    error={assistantError}
                    onClose={handleCloseAssistant}
                />
            )}
        </div>
    );
}
---------------------------------------------------------------------------------------------------------
ErrorDisplay.jsx
---------------
// app/components/ErrorDisplay.jsx
import React from 'react';

export default function ErrorDisplay({ message, onRetry, isMinor = false }) {
    const baseClasses = "p-4 rounded-md border";
    const colorClasses = isMinor
        ? "bg-yellow-50 border-yellow-300 text-yellow-800"
        : "bg-red-50 border-red-300 text-red-800";

    return (
        <div className={`${baseClasses} ${colorClasses}`} role="alert">
            <p>
                <span className="font-medium">{isMinor ? 'Warning:' : 'Error:'}</span> {message || 'An unexpected error occurred.'}
            </p>
            {onRetry && !isMinor && (
                <button
                    onClick={onRetry}
                    className="mt-2 text-sm font-medium text-red-700 hover:underline"
                >
                    Try again
                </button>
            )}
        </div>
    );
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
LoadingSpinner.jsx
---------------
// app/components/LoadingSpinner.jsx
import React from 'react';

export default function LoadingSpinner({ text = 'Loading...' }) {
    return (
        <div className="flex items-center justify-center p-4 space-x-2">
            <div className="w-6 h-6 border-4 border-blue-500 border-dashed rounded-full animate-spin"></div>
            <span className="text-gray-600">{text}</span>
        </div>
    );
}

---------------------------------------------------------------------------------------------------------
Mentionltem.jsx
---------------
// app/components/MentionItem.jsx
import React from 'react';
import SentimentBadge from './SentimentBadge';

// Helper to format dates (you might want a more robust library like date-fns)
const formatDate = (isoString) => {
    if (!isoString) return 'N/A';
    try {
        return new Date(isoString).toLocaleString();
    } catch (e) {
        return 'Invalid Date';
    }
};


export default function MentionItem({ mention, onAssistClick }) {
    // Destructure expected properties from the mention object
    const {
        id,
        text,
        source,
        url,
        sentiment,
        tone,
        intent,
        riskScore,
        timestamp,
        threadPopularity, // Example extra data
        velocity // Example extra data
    } = mention;

    // Basic risk score styling (adjust thresholds and colors)
    const getRiskColor = (score) => {
        if (score >= 75) return 'text-red-600 font-bold';
        if (score >= 50) return 'text-yellow-600 font-semibold';
        if (score >= 25) return 'text-blue-600';
        return 'text-gray-500';
    };

    return (
        <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200 hover:shadow-lg transition-shadow duration-200">
            <div className="flex justify-between items-start mb-2">
                <div>
                    <span className="font-semibold text-lg mr-2 capitalize">{source || 'Unknown Source'}</span>
                    <span className={`text-sm ${getRiskColor(riskScore)}`}>
                        Risk: {riskScore?.toFixed(0) ?? 'N/A'}
                    </span>
                </div>
                <span className="text-xs text-gray-500">{formatDate(timestamp)}</span>
            </div>

            <p className="text-gray-800 mb-3 leading-relaxed line-clamp-3">{text || 'No content available.'}</p> {/* Limit initial text display */}

            <div className="flex flex-wrap gap-2 items-center mb-3 text-sm">
                <SentimentBadge type="sentiment" value={sentiment} />
                <SentimentBadge type="tone" value={tone} />
                <SentimentBadge type="intent" value={intent} />
                {/* Display other metadata */}
                {velocity !== undefined && <span className="text-xs bg-gray-200 px-2 py-0.5 rounded">Velocity: {velocity.toFixed(1)}/hr</span>}
                {threadPopularity !== undefined && <span className="text-xs bg-gray-200 px-2 py-0.5 rounded">Popularity: {threadPopularity}</span>}
            </div>


            <div className="flex justify-between items-center mt-2">
                <a
                    href={url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-800 hover:underline text-sm"
                    onClick={(e) => e.stopPropagation()} // Prevent card click if link is clicked
                >
                    View Source
                </a>
                <button
                    onClick={() => onAssistClick(mention)}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium py-1 px-3 rounded-md transition duration-150 ease-in-out"
                    aria-label={`Get AI assistance for mention ${id}`}
                >
                    Suggest Response
                </button>
            </div>
        </div>
    );
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MentionList.jsx
---------------
// app/components/MentionList.jsx
import React from 'react';
import MentionItem from './MentionItem';

export default function MentionList({ mentions, onAssistClick }) {
    if (!mentions || mentions.length === 0) {
        return <p className="text-center text-gray-500 py-4">No mentions to display.</p>;
    }

    return (
        <div className="space-y-4">
            {mentions.map((mention) => (
                <MentionItem
                    key={mention.id} // Make sure each mention has a unique ID from the backend
                    mention={mention}
                    onAssistClick={onAssistClick}
                />
            ))}
        </div>
    );
}
---------------------------------------------------------------------------------------------------------
ResponseAssistant.jsx
----------------------
// app/components/ResponseAssistant.jsx
import React from 'react';
import LoadingSpinner from './LoadingSpinner';
import ErrorDisplay from './ErrorDisplay';

export default function ResponseAssistant({ mention, response, isLoading, error, onClose }) {
    if (!mention) return null; // Don't render if no mention is selected

    return (
        // Basic Modal structure using Tailwind (you might prefer a dedicated modal library)
        <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl relative max-h-[90vh] overflow-y-auto">
                <button
                    onClick={onClose}
                    className="absolute top-3 right-3 text-gray-500 hover:text-gray-800 text-2xl font-bold"
                    aria-label="Close assistant"
                >
                    &times; {/* Close icon */}
                </button>

                <h3 className="text-xl font-semibold mb-4 text-gray-800">AI Response Assistant</h3>

                {/* Original Mention Context */}
                <div className="mb-4 p-3 bg-gray-50 rounded border border-gray-200">
                    <h4 className="font-semibold text-sm mb-1 text-gray-600">Original Mention:</h4>
                    <p className="text-sm text-gray-700 mb-1 italic">"{mention.text}"</p>
                    <p className="text-xs text-gray-500">Source: {mention.source} | Sentiment: {mention.sentiment} | Tone: {mention.tone}</p>
                    {mention.url && <a href={mention.url} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-500 hover:underline">View Source</a>}
                </div>

                {/* AI Response Section */}
                <div className="mt-4">
                    <h4 className="font-semibold text-sm mb-2 text-gray-600">Suggested Response & Strategy:</h4>
                    {isLoading && <LoadingSpinner text="Generating suggestions..." />}
                    {error && <ErrorDisplay message={error} isMinor={true} />}
                    {response && !isLoading && !error && (
                        <div className="space-y-3 p-3 bg-green-50 rounded border border-green-200">
                            {response.suggestion && (
                                <div>
                                    <strong className="text-sm text-green-800">Suggested Text:</strong>
                                    <p className="text-sm text-gray-700 whitespace-pre-wrap bg-white p-2 rounded border border-gray-200 mt-1">{response.suggestion}</p>
                                </div>
                            )}
                            {response.strategy && (
                                <div>
                                    <strong className="text-sm text-green-800">Engagement Strategy:</strong>
                                    <p className="text-sm text-gray-700 whitespace-pre-wrap mt-1">{response.strategy}</p>
                                </div>
                            )}
                            {/* Add other fields from the response if available (e.g., similar past issues) */}
                        </div>
                    )}
                </div>

                <button
                    onClick={onClose}
                    className="mt-6 bg-gray-500 hover:bg-gray-600 text-white text-sm font-medium py-2 px-4 rounded-md transition duration-150 ease-in-out"
                >
                    Close Assistant
                </button>
            </div>
        </div>
    );
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SentimentBadge.jsx
-------------------
// app/components/SentimentBadge.jsx
import React from 'react';

// Define colors based on type and value (customize these extensively)
const BADGE_STYLES = {
    sentiment: {
        negative: 'bg-red-100 text-red-800 border border-red-300',
        neutral: 'bg-gray-100 text-gray-800 border border-gray-300',
        positive: 'bg-green-100 text-green-800 border border-green-300',
        default: 'bg-gray-100 text-gray-800 border border-gray-300',
    },
    tone: {
        angry: 'bg-red-200 text-red-900 border border-red-400',
        confused: 'bg-yellow-100 text-yellow-800 border border-yellow-300',
        sarcastic: 'bg-purple-100 text-purple-800 border border-purple-300',
        default: 'bg-blue-100 text-blue-800 border border-blue-300', // Default for other tones
    },
    intent: {
        complaint: 'bg-orange-100 text-orange-800 border border-orange-300',
        question: 'bg-teal-100 text-teal-800 border border-teal-300',
        rant: 'bg-pink-100 text-pink-800 border border-pink-300',
        meme: 'bg-indigo-100 text-indigo-800 border border-indigo-300',
        default: 'bg-gray-100 text-gray-800 border border-gray-300',
    },
    // Add more types if needed
};

export default function SentimentBadge({ type = 'sentiment', value }) {
    if (!value) return null; // Don't render if no value

    const valueLower = String(value).toLowerCase();
    const styles = BADGE_STYLES[type] || BADGE_STYLES.sentiment; // Fallback type
    const colorClass = styles[valueLower] || styles.default;

    return (
        <span
            className={`inline-block px-2 py-0.5 rounded-full text-xs font-medium capitalize ${colorClass}`}
        >
            {`${type}: ${value}`}
        </span>
    );
}